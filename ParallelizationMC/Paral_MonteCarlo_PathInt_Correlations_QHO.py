# -*- coding: utf-8 -*-
"""MonteCarlo_PathInt_QHO_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fEL0RnR7eKCarwatHx0IX30aL19yYxOj
"""

import numpy as np
import math
import matplotlib.pyplot as plt
from tqdm import tqdm

#For Paralelization with mpi
from mpi4py import MPI
# Perform calculations based on the rank
import time
start_total_time = time.time()
start_total_timeS = time.time()
# Initialize MPI
comm = MPI.COMM_WORLD
rank = comm.Get_rank()


# x_code is x_phys/dt in 2 differente ways
# 1. when dt=1, m=m_phys -----> x_normcode=x_physical/1
# 2. when dt=0.1=m, m_phys=1 -----> x_code=x_physical/dt ----->x_code*dt=x_physical (for theoretical or code calculations)
# also x_code=x_physical/dt=x_normcode/dt this is 2. with 1.

# As de distance is defined in terms of dt (x=x_fisica/dt)
# and m=mfisica*dt is taken as the efective lattice spacing if dt=1 interchange with the mfisica so that --->dt=m<---- (effective lattice spacing) and mfisica=1
# As in our code dt_code=1, x needs to be rescaled so that x = x2EV/dt_lattice, same applies for the anallytical solution
# x_code=x_fisico/1 ----> x_paper=x_fisico/dt_lattice=x_code/dt_lattice

"""
#MetropolisHasting
class MetropolisHasting:

  accrate=0
  t_min=
  t_plu=
  i=

  def __init__ (self,Nt,path,h,m,w):
    self.s_new=s_new
    self.s_old=s_old

    self.xpath_new=xpath_new
    randm=np.array(2*Nt)
    Index=np.array(Nt)

path=np.array(1)
"""

"""
# Quantum Harmonic Oscillator Lagrangian
def lagrangian_qho(x, m, omega):
    kinetic = 0.5 * m * (np.diff(x)/dt)**2
    potential = 0.5 * m * omega**2 * x**2
    return kinetic - potential

phi=np.zeros(N) #Init cont field=number of lattice points
# QFT Scalar Field Theory Lagrangian
def lagrangian_qft(phi, m, lambda_, lattice_spacing):
    kinetic = 0.5 * np.sum((np.roll(phi, 1, axis=0) - phi)**2)
    mass_term = 0.5 * m**2 * np.sum(phi**2)
    interaction = lambda_ / 4! * np.sum(phi**4)
    return kinetic - mass_term - interaction
"""
def ExpectValX24(Nt,w,m):
  R=1+(w**2)/2-w*(1+(w**2)/4)**(1/2)
  alfa=(1+R**Nt)/(1-R**Nt)
  x2EV=(1/(2*m*w*(1+(w**2)/4)**(1/2)))*alfa
  x4EV=3*x2EV**2
  #print(x4EV)
  #x4EV2=(3/(2*m*w)**2*(1+(w**2)/4))*alfa**2
  #print(x4EV2)

  # 2. when dt=0.1=m, m_phys=1 -----> x_theo=x_physical/dt ----->x_theo*dt=x_physical (for theoretical or code calculations)

  return x2EV*w**2, x4EV*w**4

####### MonteCarlo Estimate Calculation #######
def E_MCX2(x):
    Emc=np.sum(x**2)/len(x)
    return Emc

def E_MCX1(x):
    Emc=np.sum(x)/len(x)
    return Emc

def E_MCX3(x):
    Emc=np.sum(x**3)/len(x)
    return Emc

def E_MCX4(x):
    Emc=np.sum(x**4)/len(x)
    return Emc

#MetropolisHastings
def MetropolisHS(Nt,path,h,m,w): #path (array) with Nt sites

  accrate=0
  #t=0
  #tmin=0
  #tplu=0
  #i=
  #s_new=0#s_new
  #s_old=(1/2)*m*(path[tplu]-path[t])**2 + (1/2)*m*(path[t]-path[tmin])**2 + (1/2)*m*w*(path[t])**2 #current action value

  #xpath_new=xpath_new
  randm=np.zeros(2*Nt)
  index=np.zeros(Nt)
  #path=np.array(1)
  dt=np.zeros(Nt)
  x2EV=np.zeros(Nt)
  x4EV=np.zeros(Nt)
  Emc=np.zeros(Nt)

  #specify the random site visiting order
  for i in range(0,Nt-1,1):
    index[i]=int(math.floor(Nt*np.random.rand())) #an array of random "times", [0,Nt]
  #index=math.floor(Nt*np.random.rand(Nt)) #an array of random "times", [0,Nt]

  #produces an array of uniform [0,1] random numbers
  #for i in range(0,2*Nt,1):
  #  randm[i]=np.random.rand()
  randm=np.random.rand(2*Nt)

  for i in range(0,Nt-1,1): #update the path
    #dt=1
    t=int(index[i]) # a site to visit, randomly selected
    #print(t)
    tmin=(t+(Nt-1)) % Nt #periodic conditions
    tplu=(t+(1)) % Nt
    #dt[t]=tplu-tmin
    #print(dt[t])
    xpath_new=path[t]+h*(randm[i]-0.5) #propose new value for path[t]
    #dt[t]=xpath_new-path[t]??
    #m=m*dt
    #w=w*dt

    s_old= (1/2)*m*(path[tplu]-path[t])**2 + (1/2)*m*(path[t]-path[tmin])**2 + (1/2)*m*w**2*(path[t])**2 #current action value
    s_new= (1/2)*m*(path[tplu]-xpath_new)**2 + (1/2)*m*(xpath_new-path[tmin])**2 + (1/2)*m*w**2*(xpath_new)**2 #current action value

    #1 Metropolis-Hastings
    #If the action is lowered by the proposed change, e−snew +sold > 1, then the change is mad
    #If snew > sold, the use of the random number, uniformly distributed in the interval [0, 1[, ensures that the proposal is accepted
    #with the probability e−snew +sold .
    if (randm[Nt+i] < np.exp(-s_new+s_old)): #exp-s_n+s_o is the ratio of probabilities
    #if (s_new > s_old) and ( np.exp(-s_new+s_old) <= randm[Nt+i] ): #Landau, Paez
      #print("xpath_new-path[t]")
      path[t]=xpath_new
      #dt[t]=xpath_new-path[t]???
      accrate=accrate +1/Nt #adjustment of acceptance rate? update accordingly



    """
    #2 Metropolis is a particular case of M-H
    ds=s_new-s_old

    F=−kB​Tnp.log(np.exp(-s_new+s_old)) #-np.log(Prob xnew/Prob xold)
    ds=-dF/dT #or
    ds=-np.log(Prob xnew/Prob xold)

    if d_S<0:
    phi.append(phi_p)

    elif d_S>0:
    x = np.random.random()

      if x<expint(phi_p,mu,c)/expint(phi[-1],mu,c):
        phi.append(phi_p)

      elif x>expint(phi_p,mu,c)/expint(phi_0,mu,c):
        pass
    """

    x2EV[i], x4EV[i]=1,2 #ExpectValX24(Nt,w,m)
  idrate=0.8
  h=h*accrate/(idrate) #adjust target interval for future use #step size h is adjusted based on the acceptance rate

  ####### MonteCarlo Estimate Calculation #######
  #print(path)
  Emc2=E_MCX2(path)
  Emc1=E_MCX1(path)
  Emc3=E_MCX3(path)
  Emc4=E_MCX4(path)
  return path,h, x2EV, x4EV,dt, index, Emc1, Emc2, Emc3, Emc4

#we run a series of simulations, each with a smaller efective lattice spacing (that is, a smaller value of
#~m) and a greater value of Nt than the previous, such that the product Nt ~m is fxed.
#reduccion de varianza?

"""
#Adjustment of Acceptance Rate:
#accrate keeps track of the acceptance rate.
#It is updated by adding 1/N
 (where N
 is the total number of iterations) when an acceptance occurs.
#Final Step:
#The step size h is adjusted based on the acceptance rate for future iterations.
"""

###### two-point function #######


def twopf(path,deltat):

  Nt=len(path)
  G=np.zeros(len(deltat))
  for k in range(0,len(deltat)-1,1):
    sum=0
    print("deltatk",deltat[k])
    for i in range(0,Nt-1,1):
      for j in range(0,Nt-1,1):
        #print(i,j)
        #if ((j-i)%Nt-dt[i]<=0.01):
        if ((j-i)%Nt==deltat[k]):
          #print("esta",i,j)
          sum=sum+(path[i])*(path[j])
    G[k]=sum/Nt
    #print(G[i])
  return G

#Calculate the correlation function
def correlation_function(path, deltat):#correlation_function(path, deltat):
  N_tau=len(path)
  G=np.zeros(len(deltat))
  for tau in range(N_tau):
      for j in range(0,len(deltat),1): #j is Delta_tau
          #print(tau,deltat[j])
          # Periodic boundary conditions
          tau_prime = (tau + deltat[j]) % N_tau
          G[j] += (path[tau]) * (path[tau_prime])/N_tau
  return G

"""
#two-point function
def twopf(path,dt):
  sum=0
  G=np.zeros(Nt)
  for i in range(0,Nt-1,1):
    for j in range(0,Nt-1,1):
      if ((j-i)%Nt==dt[i]):
        sum=sum+path[i]*path[j]
    G[i]=(1/Nt)*sum
    #print(G[i])
  return G
"""

def twopf2A(path,t,dt):
  e=1#correlation time
  T=t[-1]#Final tim
  A=2
  G=A*np.exp(-dt/e) + A*np.exp(-(T-dt)/e)
  return G

def EffectiveMass(path,deltat):
  einv=(1/2)*np.log(correlation_function(path,(deltat-1))/correlation_function(path,(deltat+1)))
  for e in range(0,len(einv),1):
    if np.isnan(einv[e]):
      einv[e]=0
  return einv

"""##Main to perform many statistical measurements through generating paths

Trial run for Thermalization
"""

#######  Main to perform many statistical measurements through generating paths ##############
#######  Main to perform many statistical measurements through generating paths ###############

#Simulation parameters
LatticeSpacing=0.1
Nt=1200
Nsweeps=1000 #1000 or 10000
h=0.8 #free parameter accounting for acceptance rate

dtt=LatticeSpacing # Desired Lattice Spacing
m=LatticeSpacing
w=LatticeSpacing

### graph two point correlation and effective mass ####
def AvObs(G): #average observables from different random configurations
  deltat=np.arange(1,100,1)
  AvG=np.zeros(len(deltat))
  AvGSD=np.zeros(len(deltat))
  for ii in range(0,len(deltat)-1,1):
    avSum=0
    avSumSD=0
    #print("deltatii",deltat[ii])
    for jj in range(0,Nsweeps,1):
      avSum=avSum+G[jj][ii]
      #print(G[jj][ii])
    AvG[ii]=avSum/Nsweeps
    for jj in range(0,Nsweeps,1):
      avSumSD=avSumSD+(G[jj][ii]-AvG[ii])**2
      #print(G[jj][ii])
    AvGSD[ii]=np.sqrt(avSumSD/(Nsweeps-1))
  #print(AvG,type(AvG))
  return AvG,AvGSD

def JackknifeAv(O,B):

  if (O.ndim==2): #if the numpy array is a matrix, take only delta tau = 1
    O=O.transpose()[1]
  N=len(O)
  #suma=0
  mean=0
  elim=0
  meanj=0
  variancej=0
  errorj=0
  estimatorj=np.zeros(int(N/B))

  if N % B != 0:
      drop_count = (len(O) % B)
      O = O[int(drop_count):]
      N = len(O)

  estimatorj=np.zeros(int(N/B))

  suma=0
  for n in range(0,N-1,1):  
    #print(math.isnan(O[n]))
    if (math.isinf(O[n]) or math.isnan(O[n])):
        lenn=len(O[:n])
        if lenn==0:
          lenn=1.
        O[n]=np.sum(O[:n])/lenn # if is inf replace it with the average of the previous measurements
    suma=suma+O[n]

  if N==0:
    N=1.
  mean=suma/N
  #print("O",O)
  for i in range(0,int(N/B)-1,1):
    elim=0
    for j in range(i*B,i*B+B-1,1):
      elim=elim+O[j]
    #print("4v",suma,elim,N,B)
    estimatorj[i]=(suma-elim)/(N-B)

  variancej=0
  for i in range(0,int(N/B)-1,1):
    variancej+=(N/B-1)*(estimatorj[i]-mean)**2/(N-B)
  errorj=np.sqrt(variancej)
  return meanj,errorj



def Main(dtt,m,w,Nt,Nsweeps,h):

  #path=np.zeros(Nt) #cold start #initialize path ("seed")
  path=np.random.rand(Nt) #hot start
  #observables and correlations  statistically measured from many configurations
  deltat=np.arange(1,100,1) # independet variable of the correlation measurements
  EmcX1=np.zeros(Nsweeps)
  EmcX2=np.zeros(Nsweeps)
  EmcX3=np.zeros(Nsweeps)
  EmcX4=np.zeros(Nsweeps)
  G=np.zeros((Nsweeps, len(deltat)))
  G2=np.zeros((Nsweeps, len(deltat)))
  einv=np.zeros((Nsweeps, len(deltat)))


  # for thermalization
  for dis in range(0,150,1):
    path,h, x2EV, x4EV,dt, index, EmcX1dis, EmcX2dis, EmcX3dis, EmcX4dis =MetropolisHS(Nt,path,h,m,w)
  path,h, x2EV, x4EV,dt, index, EmcX1[0], EmcX2[0], EmcX3[0], EmcX4[0] =MetropolisHS(Nt,path,h,m,w)

  path1=path*dtt
  #two point correlation function and effective mass
  #print("k=0",deltat[0])
  #print(deltat)
  #G[0]=twopf(path1,deltat)
  G2[0]=correlation_function(path, deltat)
  einv[0]=EffectiveMass(path,deltat)

  #plt.plot(Nt,x2EV)
  plt.figure(0)
  plt.plot(index,path,"*",label="Path")
  plt.ylabel("x (path)")
  plt.xlabel("time (site)")
  #plt.plot(index,h,label="h")
  plt.legend()

  """
  dt=np.zeros(Nt)
  for i in range(0,Nt,1):
    dt[i]=dt[i]+i

  print(dt)
  plt.figure(1)
  plt.plot(dt,path,"*",label="Path")
  plt.ylabel("x (path)")
  plt.xlabel("dt")
  #plt.plot(index,h,label="h")
  plt.legend()
  plt.show()

  """

  ######### Expected values (measurements) ########
  cntr=np.zeros(Nsweeps)
  for cnt in range(0,len(EmcX2),1):
    cntr[cnt]=cnt
  print("START M-H SWEEPS")
  for sweep in tqdm(range(0,Nsweeps,1)): #also one sweep is one montecarlo step per site
    #print(sweep)
    for dis in range(0,200-1,1): # discard these paths
      path,h, x2EV, x4EV,dt, index, EmcX1dis, EmcX2dis, EmcX3dis, EmcX4dis =MetropolisHS(Nt,path,h,m,w)
    path,h, x2EV, x4EV,dt, index, EmcX1[sweep], EmcX2[sweep], EmcX3[sweep], EmcX4[sweep] =MetropolisHS(Nt,path,h,m,w)

    #two point correlation function and effective mass
    path1=path*dtt
    #print("k=0",deltat[0])
    #print(deltat)
    #G[sweep]=twopf(path1,deltat)
    G2[sweep]=correlation_function(path, deltat)
    einv[sweep]=EffectiveMass(path,deltat)
    #print("einv",einv)

  #print(G2)

  ###### graph Expected value of physical position powers #######################

  #remember that in our code dt=1 and m_physical=0.1
  #so to get to dt=0.1 and m_physical=1 (mathematically equal) we do X_code=X_physical/dt ---> X_code*dt=X_physical :
  EmcX1=EmcX1*dtt
  EmcX2=EmcX2*(dtt**2)
  EmcX3=EmcX3*(dtt**3)
  EmcX4=EmcX4*(dtt**4)

  ##### graph EV of x**2

  #cntr=index??
  import math
  por=0.005
  ObservablesArray=np.zeros(4) #variables needed from paralelization
  ObsJackKArray=np.zeros(8)
  #dictionary is:
  #0-x,1-x**2,2-x**3,3-x**4,    4-G2Av,5-G2SD,6-EM,7-EMSD are, each one, vectors

  """

  ax[0,1].plot(cntr,EmcX2,"*-",label="Path estimations of average X")
  ax[0,1].set_ylabel(r"$\langle \hat{X}^2 \rangle$",fontsize=16)
  ax[0,1].tick_params(axis="both", which="major", labelsize=14)
  ax[0,1].tick_params(axis="both", which="minor", labelsize=14)
  ax[0,1].set_xlabel("Metropolis Sweeps",fontsize=14)
  #plt.plot(index,h,label="h")
  ax[0,1].legend()
  ax[0,1].grid()
  """

  #print(r"$\langle \hat{X}^2 \rangle$ average", np.sum(EmcX2)/len(EmcX2))
  print("X**2 average", np.sum(EmcX2)/len(EmcX2))
  ObservablesArray[0]=np.sum(EmcX2)/len(EmcX2)
  Mm,ObsJackKArray[0]=JackknifeAv(EmcX2,math.floor(por*len(EmcX2)))

  # graph EV of x
  """

  ax[0,0].plot(cntr,EmcX1,"*-",label="Path estimations of average X")
  ax[0,0].set_ylabel(r"$\langle \hat{X} \rangle$",fontsize=16)
  ax[0,0].tick_params(axis="both", which="major", labelsize=14)
  ax[0,0].tick_params(axis="both", which="minor", labelsize=14)
  ax[0,0].set_xlabel("Metropolis Sweeps",fontsize=14)
  #plt.plot(index,h,label="h")
  ax[0,0].legend()
  ax[0,0].grid()
  """

  print("X average", np.sum(EmcX1)/len(EmcX1))
  ObservablesArray[1]=np.sum(EmcX1)/len(EmcX1)
  Mm,ObsJackKArray[1]=JackknifeAv(EmcX1,math.floor(por*len(EmcX1)))

  # graph EV of x**3
  """

  ax[1,0].plot(cntr,EmcX3,"*-",label="Path estimations of average X")
  ax[1,0].set_ylabel(r"$\langle \hat{X}^3 \rangle$",fontsize=16)
  ax[1,0].tick_params(axis="both", which="major", labelsize=14)
  ax[1,0].tick_params(axis="both", which="minor", labelsize=14)
  ax[1,0].set_xlabel("Metropolis Sweeps",fontsize=14)
  #plt.plot(index,h,label="h")
  ax[1,0].legend()
  ax[1,0].grid()
  """

  print("X**3 average", np.sum(EmcX3)/len(EmcX3))
  ObservablesArray[2]=np.sum(EmcX3)/len(EmcX3)
  Mm,ObsJackKArray[2]=JackknifeAv(EmcX3,math.floor(por*len(EmcX3)))

  # graph EV of x**4
  """

  ax[1,1].plot(cntr,EmcX4,"*-", label="Path estimations of average X")
  ax[1,1].set_ylabel(r"$\langle \hat{X}^4 \rangle$",fontsize=16)
  ax[1,1].tick_params(axis="both", which="major", labelsize=14)
  ax[1,1].tick_params(axis="both", which="minor", labelsize=14)
  ax[1,1].set_xlabel("Metropolis Sweeps",fontsize=14)
  #plt.plot(index,h,label="h")
  ax[1,1].legend()
  ax[1,1].grid()
  """

  print("X**4 average", np.sum(EmcX4)/len(EmcX4))
  ObservablesArray[3]=np.sum(EmcX4)/len(EmcX4)
  Mm,ObsJackKArray[3]=JackknifeAv(EmcX4,math.floor(por*len(EmcX4)))

  """
  fig.show()
  fig.savefig("1stgraph.eps")
  fig.savefig("1stgraph")
  """

  ### graph two point correlation and effective mass ####
  #avG=AvObs(G)
  avG2, AvG2SD=AvObs(G2) # average of the observable as a funcion of delta tau (an array of averages)
  aveinv, AveinvSD=AvObs(einv)

  G2mj,G2ej=JackknifeAv(avG2,math.floor(por*len(G2)))
  cort_mj,cort_ej=JackknifeAv(1/einv,math.floor(por*len(einv)))
  #print("einv,Inversecorrtime",einv[1])
  ObsJackKArray[4],ObsJackKArray[5]=G2mj,G2ej
  ObsJackKArray[6],ObsJackKArray[7]=cort_mj,cort_ej

  #ObservablesArray[4],ObservablesArray[5]=avG2, AvG2SD
  #ObservablesArray[6],ObservablesArray[7]=aveinv, AveinvSD
  # slower method
  #plt.figure(2)
  #plt.plot(deltat,avG,"b*",label="2pC")
  #plt.yscale("log")
  #plt.legend()

  """
  plt.figure(3)
  plt.plot(deltat,avG2,"b*")
  #plt.errorbar(deltat,avG2, yerr=AvG2SD,fmt="*")
  plt.yscale("log")
  plt.title("Two point correlation function")
  plt.ylabel(r"$G(\Delta \tau)$",fontsize=16)
  plt.xlabel(r"$\Delta \tau$",fontsize=14)
  plt.tick_params(axis="both", which="major", labelsize=14)
  plt.tick_params(axis="both", which="minor", labelsize=14)
  plt.grid()
  #plt.legend()
  #print(G)
  #print(G2)

  plt.figure(4)
  plt.plot(deltat,aveinv,"*")
  #plt.errorbar(deltat,aveinv,yerr=AveinvSD,fmt="*")
  plt.title("Two point correlation function")
  plt.ylabel(r"$M_{eff}(\Delta \tau)$",fontsize=16)
  plt.xlabel(r"$\Delta \tau$",fontsize=14)
  plt.tick_params(axis="both", which="major", labelsize=14)
  plt.tick_params(axis="both", which="minor", labelsize=14)
  plt.grid()
  #plt.legend()
  plt.show()


  ### with error bars ####


  figs, axs= plt.subplots(2,1, figsize=(8,12))
  axs[0].plot(deltat,avG2,"b*")
  axs[0].errorbar(deltat,avG2, yerr=AvG2SD)
  #axs[0].errorbar(deltat,avG2, yerr=G2ej)
  axs[0].set_yscale("log")
  axs[0].set_title("Two point correlation function")
  axs[0].set_ylabel(r"$G(\Delta \tau)$",fontsize=16)
  axs[0].set_xlabel(r"$\Delta \tau$",fontsize=14)
  axs[0].tick_params(axis="both", which="major", labelsize=14)
  axs[0].tick_params(axis="both", which="minor", labelsize=14)
  axs[0].set_ylim(10**-2,10**2)
  axs[0].set_xlim(0,100)
  axs[0].grid()
  #plt.legend()
  #print(G)
  #print(G2)

  axs[1].plot(deltat,aveinv,"*")
  axs[1].errorbar(deltat,aveinv,yerr=AveinvSD)
  #axs[1].errorbar(deltat,aveinv,yerr=1/cort_ej)#?
  axs[1].set_title("Two point correlation function")
  axs[1].set_ylabel(r"$M_{eff}(\Delta \tau)$",fontsize=16)
  axs[1].set_xlabel(r"$\Delta \tau$",fontsize=14)
  axs[1].tick_params(axis="both", which="major", labelsize=14)
  axs[1].tick_params(axis="both", which="minor", labelsize=14)
  axs[1].set_ylim(-0.7,0.7)
  axs[1].set_xlim(0,100)
  axs[1].grid()
  #plt.legend()
  figs.show()
  figs.savefig("2ndgraph.eps")
  figs.savefig("2ndgraph")
  """


  EmcX1_120_1=EmcX1
  EmcX2_120_1=EmcX2
  EmcX3_120_1=EmcX3
  EmcX4_120_1=EmcX4

  print(Nt,m)
  name="ObsfromMeasurements_" + str(Nt) + ".npy" #"R" + str(rank) +
  with open(name, 'wb') as f:

      np.save(f, ObservablesArray)
      np.save(f, np.array(avG2))
      np.save(f, np.array(AvG2SD))
      np.save(f, np.array(aveinv))
      np.save(f, np.array(AveinvSD))
      np.save(f, ObsJackKArray)

  with open(name, 'rb') as f:

      o = np.load(f)
      g2 = np.load(f)[1]
      g2sd = np.load(f)[1]
      eminv = np.load(f)[1]
      eminvsd = np.load(f)[1]
      oJK = np.load(f)

  print(o,g2,g2sd,eminv,eminvsd,oJK)

  return EmcX1_120_1,EmcX2_120_1,EmcX3_120_1,EmcX4_120_1

#fig, ax= plt.subplots(3,2, figsize=(14,14))
#EmcX1_120_1,EmcX2_120_1,EmcX3_120_1,EmcX4_120_1 = Main(dtt,m,w,Nt,Nsweeps,h)

# **Paralelization**

#Simulation parameters for MPI or Multiprocessing paralelization
LatticeSpacing=[0.08,0.1,0.3,0.5,0.8,1.]
Nt=[1500,1200,400,240,150,120]

Nsweeps=5000 #1000 or 10000
h=0.8 #free parameter accounting for acceptance rate




"""
# FOR IN SERIE CALCULATION
# Commented out IPython magic to ensure Python compatibility.
for i in range(len(LatticeSpacing)-1):
  dtt=LatticeSpacing[i] # Desired Lattice Spacing
  m=LatticeSpacing[i]
  w=LatticeSpacing[i]
  Nti=Nt[i]
  #print(MCInt(Regions[i],Regions[i+1],MaxN,DampedSinA,a,w,phi,gamma,c))
  fig, ax= plt.subplots(3,2, figsize=(14,14))
  EmcX1_120_1,EmcX2_120_1,EmcX3_120_1,EmcX4_120_1 = Main(dtt,m,w,Nti,Nsweeps,h)

end_total_timeS = time.time()
execution_total_timeS = end_total_timeS - start_total_timeS
print("Execution time Series:", execution_total_timeS, "seconds")
"""



"""#MPI"""


if rank == 0:
    start_time1 = time.time()
    print("rank: ",rank)
    dtt=LatticeSpacing[rank] # Desired Lattice Spacing
    m=LatticeSpacing[rank]
    w=LatticeSpacing[rank]
    Nti=Nt[rank]

    #dtt=LatticeSpacing[rank+3] # Desired Lattice Spacing
    #m=LatticeSpacing[rank+3]
    #w=LatticeSpacing[rank+3]
    #Nti=Nt[rank+3]

    #print(MCInt(Regions[i],Regions[i+1],MaxN,DampedSinA,a,w,phi,gamma,c))
    #fig, ax= plt.subplots(3,2, figsize=(14,14))
    EmcX1_120_1,EmcX2_120_1,EmcX3_120_1,EmcX4_120_1 = Main(dtt,m,w,Nti,Nsweeps,h)

    end_time1 = time.time()
    execution_time1 = end_time1 - start_time1
    print("Rank and Execution time 1:"+str(rank), execution_time1, "seconds")

    print("rank: ",rank+3)
    dtt=LatticeSpacing[rank+3] # Desired Lattice Spacing
    m=LatticeSpacing[rank+3]
    w=LatticeSpacing[rank+3]
    Nti=Nt[rank+3]
    #print(MCInt(Regions[i],Regions[i+1],MaxN,DampedSinA,a,w,phi,gamma,c))
    #fig, ax= plt.subplots(3,2, figsize=(14,14))
    EmcX1_120_1,EmcX2_120_1,EmcX3_120_1,EmcX4_120_1 = Main(dtt,m,w,Nti,Nsweeps,h)


if rank == 1:
    start_time = time.time()
    print("rank: ",rank)
    dtt=LatticeSpacing[rank] # Desired Lattice Spacing
    m=LatticeSpacing[rank]
    w=LatticeSpacing[rank]
    Nti=Nt[rank]

    #dtt=LatticeSpacing[rank+3] # Desired Lattice Spacing
    #m=LatticeSpacing[rank+3]
    #w=LatticeSpacing[rank+3]
    #Nti=Nt[rank+3]

    #print(MCInt(Regions[i],Regions[i+1],MaxN,DampedSinA,a,w,phi,gamma,c))
    #fig, ax= plt.subplots(3,2, figsize=(14,14))
    EmcX1_120_1,EmcX2_120_1,EmcX3_120_1,EmcX4_120_1 = Main(dtt,m,w,Nti,Nsweeps,h)

    end_time = time.time()
    execution_time = end_time - start_time
    print("Rank and Execution time:"+str(rank), execution_time, "seconds")

    print("rank: ",rank+3)
    dtt=LatticeSpacing[rank+3] # Desired Lattice Spacing
    m=LatticeSpacing[rank+3]
    w=LatticeSpacing[rank+3]
    Nti=Nt[rank+3]
    #print(MCInt(Regions[i],Regions[i+1],MaxN,DampedSinA,a,w,phi,gamma,c))
    #fig, ax= plt.subplots(3,2, figsize=(14,14))
    EmcX1_120_1,EmcX2_120_1,EmcX3_120_1,EmcX4_120_1 = Main(dtt,m,w,Nti,Nsweeps,h)

if rank == 2:
    start_time = time.time()
    print("rank: ",rank)
    dtt=LatticeSpacing[rank] # Desired Lattice Spacing
    m=LatticeSpacing[rank]
    w=LatticeSpacing[rank]
    Nti=Nt[rank]

    #dtt=LatticeSpacing[rank+3] # Desired Lattice Spacing
    #m=LatticeSpacing[rank+3]
    #w=LatticeSpacing[rank+3]
    #Nti=Nt[rank+3]

    #print(MCInt(Regions[i],Regions[i+1],MaxN,DampedSinA,a,w,phi,gamma,c))
    #fig, ax= plt.subplots(3,2, figsize=(14,14))
    EmcX1_120_1,EmcX2_120_1,EmcX3_120_1,EmcX4_120_1 = Main(dtt,m,w,Nti,Nsweeps,h)

    end_time = time.time()
    execution_time = end_time - start_time
    print("Rank and Execution time:"+str(rank), execution_time, "seconds")

    print("rank: ",rank+3)
    dtt=LatticeSpacing[rank+3] # Desired Lattice Spacing
    m=LatticeSpacing[rank+3]
    w=LatticeSpacing[rank+3]
    Nti=Nt[rank+3]
    #print(MCInt(Regions[i],Regions[i+1],MaxN,DampedSinA,a,w,phi,gamma,c))
    #fig, ax= plt.subplots(3,2, figsize=(14,14))
    EmcX1_120_1,EmcX2_120_1,EmcX3_120_1,EmcX4_120_1 = Main(dtt,m,w,Nti,Nsweeps,h)

# Finalize MPI
MPI.Finalize()

end_total_time = time.time()
execution_total_time = end_total_time - start_total_time
print("Execution time:", execution_total_time, "seconds")
#print("execution_time1",execution_time1,"execution_total_time",execution_total_time)


"""# Theoretical comparison with calculated $⟨x^{4}⟩$"""
"""
#elt=np.arange(0.01,1,0.001) #Effective lattice spacing
#Ntcons=np.arange(12000,120)
elt=np.linspace(0.01,10,1000) #Effective lattice spacing
Ntcons=np.linspace(12000,12,1000)
#print(Ntcons)
x2EV=np.zeros(len(elt))
x4EV=np.zeros(len(elt))

for i in range(0,len(elt),1):
  x2EV[i], x4EV[i]=ExpectValX24(Ntcons[i],elt[i],elt[i])
  #print(Ntcons[i],elt[i])

plt.figure(0)
eltdis=[0.05,0.1,1]
x4EVdis=[0.49,0.75,0.6]
plt.plot(elt,x4EV,label="theoretical")
plt.plot(eltdis,x4EVdis,"o",label="Sim Average")
plt.xscale("log")
plt.xlabel("Effective lattice spacing")
plt.ylabel(r"$⟨X^{4}⟩$")
plt.ylim(0.55,0.8)
plt.xlim(10**-2,3)
plt.grid()
plt.legend()
fig.show()

plt.figure(1)
eltdis=[0.05,0.1,1]
x2EVdis=[0.41,0.5,0.45]

plt.plot(elt,x2EV,label="theoretical")
plt.plot(eltdis,x2EVdis,"o",label="Sim Average")
#plt.errorbar(eltdis,x2EVdis, yerr=G2ej)
plt.xscale("log")
plt.xlabel("Effective lattice spacing")
plt.ylabel(r"$⟨X^{2}⟩$")
#plt.ylim(0.55,0.8)
#plt.xlim(10**-2,3)
plt.grid()
plt.legend()
plt.show()
plt.savefig("1stgraph.eps")
plt.savefig("1stgraph")
"""
